"""
Celery tasks for deposit processing
"""

import logging
from decimal import Decimal
from typing import Optional
from uuid import UUID
from datetime import datetime

from celery import current_task
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update

from app.celery_app import celery
from app.core.config import settings
from app.db.session import async_session
from app.repos.transaction_repo import get_transaction_by_id
from app.repos.wallet_repo import credit_deposit_atomic
from app.repos.audit_log_repo import create_audit_log
from app.core.redis_client import get_redis
from app.models.transaction import Transaction

# Configure logging
logger = logging.getLogger(__name__)


@celery.task(bind=True, max_retries=3, default_retry_delay=60)
def process_deposit(self, tx_id: str):
    """
    Process a deposit transaction atomically.
    
    This task handles the complete deposit processing pipeline:
    1. Validates transaction exists and is in correct state
    2. Checks confirmation threshold
    3. Credits user wallet atomically
    4. Updates transaction status
    5. Creates audit log
    
    Args:
        tx_id: Transaction UUID as string
    """
    import time
    start_ts = time.time()
    logger.info("deposit_task_started", extra={"tx_id": tx_id, "started_at": start_ts, "task_id": self.request.id})
    
    try:
        
        async def _process():
            async with async_session() as session:
                # Convert string to UUID
                try:
                    tx_uuid = UUID(tx_id)
                except ValueError:
                    logger.error(f"Invalid transaction ID format: {tx_id}")
                    return False
                
                # Import Transaction model
                from app.models.transaction import Transaction
                
                # Get transaction with row-level lock
                result = await session.execute(
                    select(Transaction)
                    .where(Transaction.id == tx_uuid)
                    .with_for_update()
                )
                transaction = result.scalar_one_or_none()
                
                if not transaction:
                    logger.error(f"Transaction not found: {tx_id}")
                    return False
                
                # Check if already processed
                if transaction.processed_at is not None:
                    logger.info(f"Transaction {tx_id} already processed at {transaction.processed_at}")
                    return True
                
                # Check transaction type
                if transaction.tx_type != "deposit":
                    logger.error(f"Transaction {tx_id} is not a deposit (type: {transaction.tx_type})")
                    return False
                
                # Check confirmations from metadata
                confirmations = 0
                if transaction.tx_metadata:
                    confirmations = transaction.tx_metadata.get("confirmations", 0)
                
                if confirmations < settings.confirmation_threshold:
                    logger.info(f"Transaction {tx_id} has insufficient confirmations: {confirmations} < {settings.confirmation_threshold}")
                    # Retry later
                    raise self.retry(countdown=300)  # Retry in 5 minutes
                
                # Credit user wallet atomically
                success, error, new_balance = await credit_deposit_atomic(
                    session=session,
                    user_id=transaction.user_id,
                    amount=transaction.amount,
                    tx_id=tx_uuid,
                    tx_hash=transaction.tx_metadata.get("tx_hash") if transaction.tx_metadata else None
                )
                
                if not success:
                    logger.error(f"Failed to credit wallet for transaction {tx_id}: {error}")
                    return False
                
                # Update transaction status
                transaction.processed_at = datetime.utcnow()
                
                # Update metadata with processing info
                if not transaction.tx_metadata:
                    transaction.tx_metadata = {}
                
                transaction.tx_metadata.update({
                    "status": "confirmed",
                    "processed_at": transaction.processed_at.isoformat(),
                    "confirmations": confirmations
                })
                
                await session.commit()
                
                # Create audit log
                await create_audit_log(
                    session=session,
                    admin_id=None,  # System action
                    action="process_deposit",
                    resource_type="transaction",
                    resource_id=tx_uuid,
                    details={
                        "tx_id": tx_id,
                        "tx_hash": transaction.tx_metadata.get("tx_hash"),
                        "amount": str(transaction.amount),
                        "currency": transaction.currency,
                        "confirmations": confirmations,
                        "new_balance": str(new_balance) if new_balance else None
                    }
                )
                
                logger.info(f"Successfully processed deposit {tx_id} for user {transaction.user_id}, amount: {transaction.amount}")
                return True
        
        # Run async function
        import asyncio
        try:
            # Try to get the current event loop
            loop = asyncio.get_running_loop()
            # If we're in an async context, create a new event loop in a thread
            import concurrent.futures
            with concurrent.futures.ThreadPoolExecutor() as executor:
                future = executor.submit(asyncio.run, _process())
                result = future.result()
                if result:
                    end_ts = time.time()
                    logger.info("deposit_task_completed", extra={"tx_id": tx_id, "completed_at": end_ts, "duration_s": end_ts - start_ts})
                return result
        except RuntimeError:
            # No event loop running, use asyncio.run()
            result = asyncio.run(_process())
            if result:
                end_ts = time.time()
                logger.info("deposit_task_completed", extra={"tx_id": tx_id, "completed_at": end_ts, "duration_s": end_ts - start_ts})
            return result
        
    except Exception as exc:
        logger.exception("deposit_task_failed", exc_info=True, extra={"tx_id": tx_id})
        if self.request.retries < self.max_retries:
            logger.info(f"Retrying deposit processing for {tx_id} (attempt {self.request.retries + 1})")
            raise self.retry(countdown=60 * (2 ** self.request.retries))  # Exponential backoff
        else:
            logger.error(f"Max retries exceeded for deposit {tx_id}")
            raise


async def get_transaction_by_hash(session: AsyncSession, tx_hash: str) -> Optional[Transaction]:
    """
    Get transaction by hash from metadata.
    
    Args:
        session: Database session
        tx_hash: Transaction hash
    
    Returns:
        Transaction instance or None if not found
    """
    from app.models.transaction import Transaction
    
    result = await session.execute(
        select(Transaction)
        .where(Transaction.tx_metadata["tx_hash"].astext == tx_hash)
    )
    return result.scalar_one_or_none()
